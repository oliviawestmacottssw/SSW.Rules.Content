---
type: rule
archivedreason: 
title: Do you clean your data before modelling?
guid: ae6c3d9b-598b-42af-aae1-6b83c1dc98f6
uri: clean-your-data-before-modelling
created: 2017-04-18T01:26:52.0000000Z
authors: []
related: []
redirects:
- do-you-clean-your-data-before-modelling

---


​​​​Without proper data cleansing, efforts spent in analysis and modelling are often wasted.  This rule covers the important steps for getting your data in good shape before the hard work begins.<br>
<br><excerpt class='endintro'></excerpt><br>
<p>​​Cleaning data is usually the first step in any data science project, and along with initially procuring the data, this step can take up a considerable amount of time.  This rule will focus on techniques and steps required for data cleansing using Python in Azure Notebooks and using in-built functionality in the Azure Machine Learning Studio.</p><h3 class="ssw15-rteElement-H3">1. Inspect the data​<br></h3><p>Once the data has been imported, the first step is to visually and graphically inspect the data.  In addition to getting a general understanding of the data, this step aims to uncover data outliers, data with formatting issues and columns where data is missing.<br></p><p>Using Python, data can be inspected in a tabular form by using the head and tail methods of a Pandas dataframe.  These methods will output the first and last five rows of a dataframe (respectively), with an optional parameter allowing the five row default to be modified.  In this step, we are looking for missing data (such as columns with NaN values) and columns where the formatting looks problematic.<br></p><p> 
   <img src="DataScience1.png" alt="" style="margin:5px;width:809px;" /> 
   <br> 
</p><p>Once we have a general sense of the data and have identified columns that contain features that are of interest to the data analysis, the next step is to plot the data to get a feeling for its distribution and to check for any outliers.  The 'plot' method of dataframes supports a rich variety of ways to graphically present data.<br><br></p><p> 
   <img src="DataScience2.png" alt="" style="margin:5px;width:809px;" />​​ 
   <br> 
   <br> 
   <br> </p><p>For Azure Machine Learning projects, the context menu of a dataset can be used to Visualize the data available for modelling.<br></p><p> 
   <img src="DataScience3.png" alt="" style="margin:5px;width:809px;" /> 
   <br>Data is displayed in a tabular form, and by selecting a column, key statistics for that column can be inspected.  Two graph types are available for the data - the default histogram view and a boxplot view.  Using this screen, any problems with a dataset can be readily identified.<br></p><p> 
   <img src="DataScience4.png" alt="" style="margin:5px;width:809px;" />​<br><br></p><h3 class="ssw15-rteElement-H3">2. Decide on a strategy for dealing with ​​​missing data</h3><p>Missing, incomplete or suspect data can be dealt with in one of four ways:</p><p></p><ol><li>​The data can be left as-is if it doesn't impact any analysis or modelling activities.<br></li><li>The rows with missing data can be excluded from the analysis.  This is a good option if the percentage of rows with bad data is small ​or the missing data cannot be ​inferred or substituted for a ​sensible value.  This is often the case for non-numeric fields.<br></li><li>The data can be set to a default value such as zero for missing numeric fields or an empty string for text columns.<br></li><li>The data can be inferred based on other values in the dataset.  This can range from simple calculations like mean or medium to highly advanced formulas like Multivariate Imputation by Chained Equations (MICE).  These techniques will be covered below.<br></li></ol><h3 class="ssw15-rteElement-H3">Data Cleaning and Inference Techniques​ in Python<br></h3><p>​To exclude data from a Python dataframe, use a query expression to exclude the rows where the data is missing, and then re-assign the filtered dataframe back to the same variable.  This will permanently remove the rows.  This first code block creates a dataframe with a NaN value in one row:<br></p><p class="ssw15-rteElement-CodeArea">import datetime​<br>import math​<br>import pandas as pd<br>import numpy as np<br><br>todays_date = datetime.datetime.now().date()<br>index = pd.date_range(todays_date-datetime.timedelta(10), periods=4, freq='D')<br>columns = ['A','B', 'C']<br>df = pd.DataFrame(index=index, columns=columns)<br>df = df.fillna(0) <br><br>df.set_value('2017-04-16', 'B', math.nan) #set one value in NaN<br><br>df.head()​<br></p><p class="ssw15-rteElement-P">Dataframe output:<br></p><table cellspacing="0" width="100%" class="ssw15-rteTable-default" summary="5"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:150px;"> 
            <br> 
         </th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:100px;">​A<br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:100px;">​B<br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:100px;">​C<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" style="width:150px;">​2017-04-14​<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">0<br></td><td class="ssw15-rteTableEvenCol-default" colspan="1" style="width:100px;">0<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">0​<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default" style="width:150px;">2​017-04-15<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">​0<br></td><td class="ssw15-rteTableEvenCol-default" colspan="1" style="width:100px;">​0<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">​0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" style="width:150px;">​2017-04-16<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">​0<br></td><td class="ssw15-rteTableEvenCol-default" colspan="1" style="width:100px;">​NaN<br><br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">​0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default" style="width:150px;">​2017-04-17<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">0<br></td><td class="ssw15-rteTableEvenCol-default" colspan="1" style="width:100px;">0<br></td><td class="ssw15-rteTableOddCol-default" style="width:100px;">0​<br></td></tr></tbody></table><p class="ssw15-rteElement-P">​​​​​Filtering out this row is simple using a square bracket filter expression.  Here we are filtering using the Numpy isfinite method on column B to exclude the problematic row:<br></p><p class="ssw15-rteElement-CodeArea">df = df.loc[np.isfinite(df['B'])] #filter out the NaN row<br>df.head()​<br></p><p class="ssw15-rteElement-P">Dataframe output:​<br></p><table cellspacing="0" width="100%" class="ssw15-rteTable-default"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:25%;">​<br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:25%;">​A<br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:25%;">​B<br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:25%;">​C<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2017-04-14​<br></td><td class="ssw15-rteTableOddCol-default">​0​​​<br></td><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​2​017-04-15<br></td><td class="ssw15-rteTableOddCol-default">​0<br></td><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2017-04-17<br></td><td class="ssw15-rteTableOddCol-default">​0<br></td><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​0<br></td></tr></tbody></table><p> 
   <br>There is also inbuilt functionality in a dataframe to fill values by interpolation or by taking the mean value of a column.  In the dataframe sample below, it is clear that this is a relationship between row values, with each row showing an increase in the values of each column, making interpolation a valid technique for filling missing data.<br></p><p>This first code sample great a dataframe with a number of rows with incomplete data.<br></p><p class="ssw15-rteElement-CodeArea">df2 = pd.DataFrame({'Col1': [1, 2, np.nan, 4.8, 6],'Col2': [11, np.nan, np.nan, 16, 28]})<br>df2</p><table cellspacing="0" width="100%" class="ssw15-rteTable-default"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​​<br><br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col1<br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col2<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​1.0<br></td><td class="ssw15-rteTableEvenCol-default">​11.0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​1<br></td><td class="ssw15-rteTableOddCol-default">​2.0<br></td><td class="ssw15-rteTableEvenCol-default">​NaN<br><br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2<br></td><td class="ssw15-rteTableOddCol-default">​NaN<br><br></td><td class="ssw15-rteTableEvenCol-default">​NaN<br><br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​3<br></td><td class="ssw15-rteTableOddCol-default">​4.8<br></td><td class="ssw15-rteTableEvenCol-default">16.0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" rowspan="1">​4<br></td><td class="ssw15-rteTableOddCol-default" rowspan="1">​6.0<br></td><td class="ssw15-rteTableEvenCol-default" rowspan="1">​28.0<br></td></tr></tbody></table><p class="ssw15-rteElement-P">​​​​The dataframe's inbuilt interpolate method is then used to fill the missing values.  The default behaviour of interpolate is to use a linear interpolation, but a number of more advanced algorithms are also available.  See the <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.interpolate.html">interpolation documentation​</a> for more information.<br></p><p class="ssw15-rteElement-CodeArea">df2 = df2.interpolate()<br>df2</p><table cellspacing="0" width="100%" class="ssw15-rteTable-default"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​​<br><br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col1<br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col2<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​1.0<br></td><td class="ssw15-rteTableEvenCol-default">​11.0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​1<br></td><td class="ssw15-rteTableOddCol-default">​2.0<br></td><td class="ssw15-rteTableEvenCol-default">​12.66667<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2<br></td><td class="ssw15-rteTableOddCol-default">​3.4<br></td><td class="ssw15-rteTableEvenCol-default">​14.33333<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​3<br></td><td class="ssw15-rteTableOddCol-default">​4.8<br></td><td class="ssw15-rteTableEvenCol-default">16.0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" rowspan="1">​4<br></td><td class="ssw15-rteTableOddCol-default" rowspan="1">​6.0<br></td><td class="ssw15-rteTableEvenCol-default" rowspan="1">​28.0<br></td></tr></tbody></table>​In this code sample, the mean value of a column is used to fill missing data.<br>
<p class="ssw15-rteElement-CodeArea">df3 = pd.DataFrame({'Col1': [1, 2, np.nan, 4.8, 6],'Col2': [11, np.nan, np.nan, 16, 28]})<br>df3<br></p><table cellspacing="0" width="100%" class="ssw15-rteTable-default"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​​<br><br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col1​<br><br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col2<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​1.0<br></td><td class="ssw15-rteTableEvenCol-default">​11.0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​1<br></td><td class="ssw15-rteTableOddCol-default">​2.0<br></td><td class="ssw15-rteTableEvenCol-default">​NaN<br><br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2<br></td><td class="ssw15-rteTableOddCol-default">​NaN<br><br></td><td class="ssw15-rteTableEvenCol-default">​NaN<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​3<br></td><td class="ssw15-rteTableOddCol-default">​4.8<br></td><td class="ssw15-rteTableEvenCol-default">16.0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" rowspan="1">​4<br></td><td class="ssw15-rteTableOddCol-default" rowspan="1">​6.0<br></td><td class="ssw15-rteTableEvenCol-default" rowspan="1">​28.0<br></td></tr></tbody></table><p class="ssw15-rteElement-CodeArea">df3 = df3.fillna(df3.mean())<br>df3<br></p><table cellspacing="0" width="100%" class="ssw15-rteTable-default"><tbody><tr class="ssw15-rteTableHeaderRow-default"><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​​<br><br></th><th class="ssw15-rteTableHeaderOddCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col1<br></th><th class="ssw15-rteTableHeaderEvenCol-default" rowspan="1" colspan="1" style="width:33.3333%;">​Col2<br></th></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​0<br></td><td class="ssw15-rteTableOddCol-default">​1.0<br></td><td class="ssw15-rteTableEvenCol-default">​11.0<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​1<br></td><td class="ssw15-rteTableOddCol-default">​2.0<br></td><td class="ssw15-rteTableEvenCol-default">18.33<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default">​2<br></td><td class="ssw15-rteTableOddCol-default">​3.45<br></td><td class="ssw15-rteTableEvenCol-default">​18.33​<br></td></tr><tr class="ssw15-rteTableEvenRow-default"><td class="ssw15-rteTableEvenCol-default">​3<br></td><td class="ssw15-rteTableOddCol-default">​4.8<br></td><td class="ssw15-rteTableEvenCol-default">16.0<br></td></tr><tr class="ssw15-rteTableOddRow-default"><td class="ssw15-rteTableEvenCol-default" rowspan="1">​4<br></td><td class="ssw15-rteTableOddCol-default" rowspan="1">​6.0<br></td><td class="ssw15-rteTableEvenCol-default" rowspan="1">​28.0<br></td></tr></tbody></table>​<h3 class="ssw15-rteElement-H3">Data Cleaning and Inference Techniques​ in Azure Machine Learning<br></h3><p>Azure ML has a specific step for cleaning missing data.  The step allows the relevant columns to be selected, the minimum and maximum missing value ratios and the cleaning mode to be used.  The ratios are used to control when cleaning is applied - the default values of 0 and 1 allow cleaning to be applied on all rows, but if the cleaning should only be applied in cases where 20% to 30% of the values are missing, the values would be set to 0.2 for the minimum and 0.3 for the maximum.<br></p><p>In addition to the simple cleaning methods such as removing the row or replacing it with the mean, much more complex methods such as Replace with MICE are available.  MICE stands for Multivariate Imputation using Chained Equations, and is an inference technique that uses the distribution of values across all columns to calculate the best fitting substitution for missing values.  For example, to fill in the missing values in a person's weight column, the information in other columns such as gender and age will be used to predict the best fit for the missing data.  The academic paper <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3074241/">Multiple Imputation by Chained Equations: What is it and how does it work?​</a> gives a great explanation​ of the workings of the MICE algorithm.<br><br><br></p><p><img src="DataScience5.png" alt="" style="margin:5px;" /><br></p><h3 class="ssw15-rteElement-H3">Next Steps​​<br><br></h3>Once your data is clean, the next steps are to either move into <a href=/use-azure-notebooks-to-learn-your-data>in-depth analysis in a Azure Notebook </a>or to use <a href=/use-azure-machine-learning-to-make-predictions-from-your-data>Azure Machine Learning to look at advanced data prediction and classification​</a>.<br><br><br><br><br><br><br><br><br><br><br><br><br>


